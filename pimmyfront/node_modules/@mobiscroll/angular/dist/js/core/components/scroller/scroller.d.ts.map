{"version":3,"file":"scroller.d.ts","sources":["scroller.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { MbscPopupDisplay } from '../../components/popup/popup';\nimport { IPickerProps, IPickerState, PickerBase } from '../../shared/picker/picker';\nimport { IActiveChangeArgs, IWheelIndexChangeArgs } from '../../shared/wheel/wheel';\n/**\n * Options for all scroller based components\n */\nexport interface IScrollerProps extends IPickerProps {\n    circular?: boolean | boolean[];\n    /** @hidden */\n    displayStyle?: MbscPopupDisplay;\n    /** @hidden */\n    inContentTemplate?: any;\n    /**\n     * Height of the wheel items in pixels.\n     */\n    itemHeight?: number;\n    renderItem?: any;\n    itemTemplate?: any;\n    minWheelWidth?: number | number[];\n    maxWheelWidth?: number | number[];\n    wheelWidth?: number | number[];\n    /** @hidden */\n    preContentData?: any;\n    /** @hidden */\n    preContentTemplate?: any;\n    selectOnScroll?: boolean;\n    /**\n     * Number of visible rows on the wheel.\n     */\n    rows?: number;\n    scroll3d?: boolean;\n    onWheelMove?: (args: IWheelMoveArgs) => any[] | undefined;\n    /** @hidden */\n    renderInContent?: (inst: any) => any;\n    /** @hidden */\n    renderPreContent?: (inst: any) => any;\n    validate?: (args: IScrollerValidateArgs) => {};\n    valueEquality?: (v1: any, v2: any) => boolean;\n    /** function that is called to decide if the value should be validated */\n    shouldValidate?: (s: any, prevS: any) => boolean;\n}\n/**\n * Scroller options\n */\nexport interface MbscScrollerOptions extends IScrollerProps {\n    wheels?: MbscScrollerWheel[][];\n    formatValue?(values: any[]): string;\n    getValue?(values: any[]): any;\n    writeValue?(elm: HTMLElement, text: string, value: any): boolean;\n    parseValue?(valueStr: string): any[];\n}\n/** @hidden */\nexport interface MbscScrollerState extends IPickerState {\n    value?: any;\n}\n/** @hidden */\nexport declare type IWheelDataItem = string | number | {\n    display: string;\n    isGroup?: boolean;\n    value: any;\n};\n/** @hidden */\nexport declare type IScrollerRepresentation = any[];\nexport interface MbscScrollerWheel {\n    label?: string;\n    circular?: boolean;\n    cssClass?: string;\n    data?: IWheelDataItem[];\n    max?: number;\n    min?: number;\n    multiple?: boolean;\n    checkmark?: boolean;\n    closeOnTap?: boolean;\n    spaceAround?: boolean;\n    getItem?: (index: number) => any;\n    getIndex?: (value: any) => number;\n    _circular?: boolean;\n    _key?: number;\n    _map?: Map<any, number>;\n    _offset?: number;\n}\n/** @hidden */\nexport interface IScrollerValidateArgs {\n    direction?: number;\n    index?: number;\n    values: IScrollerRepresentation;\n    wheels: MbscScrollerWheel[];\n}\n/** @hidden */\nexport interface IWheelMoveArgs {\n    dataItem: any;\n    wheelIndex: number;\n    selection: boolean;\n}\n/**\n * Returns the closest valid value on a wheel.\n * @hidden\n * @param wheel The wheel object.\n * @param val The current value.\n * @param direction Direction of the wheel movement.\n * @param disabled Disabled values on the wheel.\n */\nexport declare function getValid(wheel: MbscScrollerWheel, val: any, disabled?: Map<any, boolean>, direction?: number): any;\n/** @hidden */\nexport declare class ScrollerBase extends PickerBase<MbscScrollerOptions, MbscScrollerState> {\n    /** @hidden */\n    static defaults: MbscScrollerOptions;\n    protected static _name: string;\n    /** @hidden */\n    _circular: boolean | boolean[] | undefined;\n    /** @hidden */\n    _disabled: Array<Map<any, boolean>>;\n    /** @hidden */\n    _displayStyle: MbscPopupDisplay;\n    /** @hidden */\n    _indexes: number[];\n    /** @hidden */\n    _activeIndexes: number[];\n    /** @hidden */\n    _lineStyle: any;\n    /** @hidden */\n    _overlayStyle: any;\n    /** @hidden */\n    _rows: number;\n    /** @hidden */\n    _scroll3d: boolean;\n    /** @hidden */\n    _wheels: MbscScrollerWheel[][];\n    private _batches;\n    /**\n     * Stores the last index that was set when selecting a value\n     * Check out the _setIndexes method for more explanations.\n     */\n    private _lastIndexes;\n    private _shouldSetIndex;\n    private _indexFromValue;\n    private _wheelMap;\n    _onSet: () => void;\n    /**\n     * Triggered when the active item is changed via keyboard navigation.\n     * When the selectOnScroll is true the onWheelIndexChange is triggered instead,\n     * because selection also happens.\n     */\n    _onActiveChange: ({ wheel, index }: IActiveChangeArgs) => void;\n    _onWheelIndexChange: (args: IWheelIndexChangeArgs) => void;\n    _initWheels(): void;\n    _shouldValidate(s: MbscScrollerOptions, prevS: MbscScrollerOptions): boolean;\n    _valueEquals(v1: any, v2: any): boolean;\n    protected _render(s: MbscScrollerOptions, state: MbscScrollerState): void;\n    protected _writeValue(elm: HTMLInputElement, text: string, value: any): boolean;\n    protected _copy(value: any[]): any[];\n    protected _format(value: any[]): string;\n    protected _get(value: any[]): any;\n    protected _parse(valueStr: any): any[];\n    /**\n     * Does the validation\n     * @param index Index of the wheel\n     * @param direction Direction the wheel was moved\n     */\n    protected _validate(index?: number, direction?: number): void;\n    protected _onOpen(): void;\n    protected _onParse(): void;\n    private _initWheel;\n    /** Indexes must be set in two occasions:\n     * 1. When the picker is opened\n     * 2. When the wheels are changed (ex. select filtering)\n     *\n     * The new index can come from the value (when opening the scroller), or from the currently scrolled to item\n     */\n    private _setIndexes;\n    /**\n     * The newIndex is the index of the topmost visible item on the scroller, but the selected item can be under that.\n     * So if the newIndex comes from the selected value, the newIndex can turn up greater than the topmost item's\n     * index. So we need to constrain the newIndex in this case, otherwise at the end of the list, there will be an\n     * empty space\n     * @param newIndex\n     * @param wheel\n     */\n    private _constrainIndex;\n}\n"]}