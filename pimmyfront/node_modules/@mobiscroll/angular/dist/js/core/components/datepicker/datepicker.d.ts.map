{"version":3,"file":"datepicker.d.ts","sources":["datepicker.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { IPickerState, PickerBase } from '../../shared/picker/picker';\nimport { DateType } from '../../util/datetime';\nimport { MbscCalendarOptions } from '../calendar/calendar';\nimport { MbscDatetimeOptions } from '../datetime/datetime';\nexport * from '../../util/luxon';\nexport * from '../../util/moment';\nexport declare const modules: {\n    [key: string]: any;\n};\nexport declare type TDatepickerControl = 'calendar' | 'date' | 'time' | 'datetime' | 'timegrid';\nexport declare const RANGE_SEPARATOR = \" - \";\ninterface IValueRepresentation {\n    [key: string]: Date;\n}\ninterface IDValueRepresentation {\n    date?: IValueRepresentation;\n    start?: number;\n    end?: number;\n}\nexport interface MbscDatepickerOptions extends MbscCalendarOptions, MbscDatetimeOptions {\n    calendarSize?: number;\n    controls?: TDatepickerControl[];\n    clearIcon?: string;\n    defaultValue?: any;\n    firstSelectDay?: number;\n    rangeHighlight?: boolean;\n    modules?: any[];\n    tabs?: boolean | 'auto';\n    rangeEndInvalid?: boolean;\n    selectCounter?: boolean;\n    select?: 'date' | 'range' | 'preset-range';\n    selectSize?: number;\n    startInput?: any;\n    endInput?: any;\n    inRangeInvalid?: boolean;\n    showRangeLabels?: boolean;\n    enableStartOnly?: boolean;\n    maxRange?: number;\n    maxTime?: DateType;\n    minRange?: number;\n    minTime?: DateType;\n    rangeEndHelp?: string;\n    rangeEndLabel?: string;\n    rangeStartHelp?: string;\n    rangeStartLabel?: string;\n    onTempChange?(args: {\n        value: DateType | DateType[];\n    }, inst: any): void;\n    onActiveDateChange?(args: {\n        active: 'start' | 'end';\n    }, inst: any): void;\n}\n/** @hidden */\nexport interface MbscDatepickerState extends IPickerState {\n    activeTab?: string;\n    hoverDate?: number;\n    isLarge?: boolean;\n    maxPopupWidth?: number;\n    widthType?: 'sm' | 'md';\n}\n/** @hidden */\nexport declare class DatepickerBase extends PickerBase<MbscDatepickerOptions, MbscDatepickerState> {\n    /** @hidden */\n    static defaults: MbscDatepickerOptions;\n    protected static _name: string;\n    _activeTab: string | undefined;\n    _activeSelect: 'start' | 'end' | undefined;\n    _controls: any[];\n    _controlsClass: string;\n    /** Whether of not to show the rangepicker start and end selection controls */\n    _renderControls: boolean;\n    _renderTabs: boolean | undefined;\n    _selectedTime: Date | undefined;\n    _tempValueRep: IDValueRepresentation;\n    _cssClass: string | undefined;\n    /** @hidden\n     * The formatted start value that appears on the start/end selection control\n     */\n    _tempStartText: string;\n    /** @hidden\n     * The formatted end value that appears on the start/end selection control\n     */\n    _tempEndText: string;\n    protected _needsWidth: boolean;\n    /** Reference to the start input element in case of the range picker */\n    private _startInput?;\n    /** Reference to the end input element in case of the range picker */\n    private _endInput?;\n    private _iso;\n    private _hasCalendar;\n    private _hasDate;\n    private _hasTime;\n    private _hasTimegrid;\n    private _max;\n    private _min;\n    /** Holds the minimum time that can be selected for each day.\n     * It's a Date object that we use only the time part of.\n     */\n    private _minTime;\n    /** Holds the maximum time that can be selected for each day.\n     * It's a Date object that we use only the time part of.\n     */\n    private _maxTime;\n    /** We pass this date to the calendar, when we want to navigate it to a certain date.\n     * The calendar takes this into account only once every time the _active value changes.\n     * Otherwise when navigated from UI, this value is disregarded.\n     */\n    private _active?;\n    private _valueFormat;\n    /** Holds the limited max option which is manipulated in the case of range selection based on invalids */\n    private _maxLimited?;\n    /** Holds the limited min option which is manipulated in the case of range selection on the datetime control based on the start date */\n    private _minLimited?;\n    /** Holds the limited min option which is passed to the time control\n     * It's required because in the case of the calendar the min setting should not be limited, but\n     * for the time control it does. So in case when there is a time and a calendar, the two passed options differ.\n     */\n    private _minTimeLimited?;\n    private _nextInvalid;\n    /** Holds the previously selected start date as a timestamp in case of the range picker */\n    private _prevStart?;\n    /** Holds the last selected date in the case of the calendar\n     * NOTE: It's needed in the case of the range picker, when both of the start and end dates are selected, and we change the end selection\n     * we can't decide which date was clicked otherwise, because the calendar change only knows the selected dates. So if we click the same\n     * day (start or end), we can't tell if the start or the end date was clicked.\n     * TODO: simplify the onCalendarChange function based on this value - currently it calculates this value from the current selection if\n     * it can, otherwise uses this value\n     */\n    private _lastSelected?;\n    /** We store the readonly state of the start input in this variable. We need this to restore the input to the original state\n     * when required.\n     */\n    private _startInputReadOnly?;\n    /** We store the readonly state of the end input in this variable. We need this to restore the input to the original state\n     * when required.\n     */\n    private _endInputReadOnly?;\n    private _shouldInitInputs?;\n    /** In the case of the rangepicker it specifies if we are making a new selection.\n     * When true, it means we need to cycle the active selection. Otherwise we refine the\n     * selection and we don't have to cycle it.\n     * Generally, we make a new selection when we open the picker (doesn't matter if there was\n     * already a selected date or not).\n     */\n    private _newSelection?;\n    private _selectedDate?;\n    private _remote;\n    private _shouldParse;\n    _onActiveChange: (ev: any) => void;\n    _onResize: (ev: any) => void;\n    _onDayHoverIn: ({ date, hidden }: {\n        date: Date;\n        hidden: boolean;\n    }) => void;\n    _onDayHoverOut: ({ date }: {\n        date: Date;\n    }) => void;\n    /** Saves the last clicked date on the calendar */\n    _onCellClick: (args: any) => void;\n    _onCalendarChange: (ev: any) => void;\n    _onDatetimeChange: (ev: any) => void;\n    _onTimePartChange: (ev: any) => void;\n    /** @hidden */\n    _changeActiveTab: (ev: any) => void;\n    /** @hidden */\n    _changeActiveSelect: (ev: any) => void;\n    /**\n     * Sets which date or time is currently selected (start or end).\n     * @param active Specifies which one should be active start or end selection.\n     */\n    setActiveDate(active: 'start' | 'end'): void;\n    /** Returns the temporary value selected on the datepicker. */\n    getTempVal(): null | DateType | DateType[] | [DateType | null, DateType | null];\n    /**\n     * Sets the datepicker temporary value. This temp value is shown on the picker until the selection.\n     * In the case of inline mode or when the touchUi setting is false the value will be set to the Model as well,\n     * since in these cases there's no temporary value.\n     * @param value The value to set to the datepicker as temporary value\n     */\n    setTempVal(value: null | DateType | Array<DateType | null>): void;\n    /**\n     * Navigates the calendar to the specified date.\n     * @param date\n     */\n    navigate(date: DateType): void;\n    _onInputClickRange: (ev: any) => void;\n    _onInputKeyRange: (ev: any) => void;\n    _onInputFocusRange: (ev: any) => void;\n    _onInputChangeRange: (ev: any) => void;\n    _clearEnd: () => void;\n    _clearStart: () => void;\n    _shouldValidate(s: MbscDatepickerOptions, prevS: MbscDatepickerOptions): boolean;\n    _valueEquals(v1: any, v2: any): boolean;\n    protected _activateBasedOnInput: (inp: HTMLInputElement) => void;\n    protected _init(): void;\n    protected _render(s: MbscDatepickerOptions, state: MbscDatepickerState): void;\n    protected _updated(): void;\n    protected _onEnterKey(args: any): void;\n    protected _setupInput(i: 'start' | 'end', input: any): void;\n    protected _destroy(): void;\n    protected _setupInputHandlers(el: HTMLInputElement): void;\n    protected _clearInputHandlers(el: HTMLInputElement | undefined, readOnly?: boolean): void;\n    protected _setHeader(): void;\n    protected _validate(): void;\n    protected _copy(value: any): any;\n    /**\n     * Formats the value representation to a string\n     * IMPORTANT: The order of the dates in the formatted string is definition order!\n     * @param valueRep The value representation object\n     */\n    protected _format(valueRep: IDValueRepresentation): string;\n    protected _proxy: (args: any) => void;\n    protected _parse(value: any, fromInput?: boolean): IDValueRepresentation;\n    protected _getDate(value: IDValueRepresentation): null | Date | Array<Date | null>;\n    /**\n     * Returns the value from the value representation\n     * NOTE: In the case of the range, if the start date is selected only, the end will be null\n     * @param value The value representation for the datepicker\n     */\n    protected _get(value: IDValueRepresentation): null | DateType | DateType[] | [DateType | null, DateType | null];\n    protected _onClosed(): void;\n    protected _onOpen(): void;\n    /** The formatted end value in the case of the range picker */\n    private _getValueText;\n    /**\n     * Checks if the temp selection is NOT ready yet for set\n     * In the case of the range picker the selection is not ready when\n     *  - no value is selected OR\n     *  - only one value is selected and the labels are shown\n     *    if the labels are not shown, we allow the selection in the case of date control or the calendar together with\n     *    time - there's no way to switch to second value otherwise\n     */\n    private _selectionNotReady;\n    /** Sets the _activeSelect property and triggers the 'onActiveDateChange' event if the active select changed */\n    private _setActiveSelect;\n}\n"]}