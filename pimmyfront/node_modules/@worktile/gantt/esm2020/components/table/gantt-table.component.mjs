import { Component, HostBinding, Input, ViewChild, Inject, Output, EventEmitter } from '@angular/core';
import { coerceCssPixelValue } from '@angular/cdk/coercion';
import { GANTT_ABSTRACT_TOKEN } from '../../gantt-abstract';
import { GANTT_UPPER_TOKEN } from '../../gantt-upper';
import { setStyleWithVendorPrefix } from '../../utils/set-style-with-vendor-prefix';
import * as i0 from "@angular/core";
import * as i1 from "../icon/icon.component";
import * as i2 from "@angular/common";
import * as i3 from "@angular/cdk/drag-drop";
import * as i4 from "../../gantt.pipe";
import * as i5 from "../../gantt-upper";
export const defaultColumnWidth = 100;
export const minColumnWidth = 80;
export class GanttTableComponent {
    constructor(gantt, ganttUpper, elementRef) {
        this.gantt = gantt;
        this.ganttUpper = ganttUpper;
        this.elementRef = elementRef;
        this.itemClick = new EventEmitter();
        this.ganttTableClass = true;
        this.ganttTableEmptyClass = false;
    }
    set columns(columns) {
        columns.forEach((column) => {
            if (!column.columnWidth) {
                column.columnWidth = coerceCssPixelValue(defaultColumnWidth);
            }
        });
        this.columnList = columns;
    }
    ngOnChanges(changes) {
        if (!changes.groups.currentValue?.length && !changes.items.currentValue?.length) {
            this.ganttTableEmptyClass = true;
        }
        else {
            this.ganttTableEmptyClass = false;
        }
    }
    dragFixed(config) {
        if (config.movedWidth < config.minWidth) {
            setStyleWithVendorPrefix({
                element: config.target,
                style: 'transform',
                value: `translate3d(${config.minWidth - config.originWidth}px, 0, 0)`
            });
        }
    }
    expandGroup(group) {
        this.gantt.expandGroup(group);
    }
    expandChildren(event, item) {
        event.stopPropagation();
        this.gantt.expandChildren(item);
    }
    dragStarted(event) {
        const target = event.source.element.nativeElement;
        this.dragStartLeft = target.getBoundingClientRect().left;
    }
    dragMoved(event, column) {
        const target = event.source.element.nativeElement;
        const left = target.getBoundingClientRect().left;
        let originWidth;
        let movedWidth;
        let minWidth;
        if (column) {
            originWidth = parseInt(column.columnWidth, 10);
            movedWidth = originWidth + (left - this.dragStartLeft);
            minWidth = minColumnWidth;
        }
        else {
            originWidth = this.elementRef.nativeElement.getBoundingClientRect().width;
            movedWidth = originWidth + (left - this.dragStartLeft);
            minWidth = minColumnWidth * this.columnList.length;
        }
        this.dragFixed({
            target,
            originWidth,
            movedWidth,
            minWidth
        });
        this.showAuxiliaryLine(event);
    }
    columnDragEnded(event, column) {
        const target = event.source.element.nativeElement;
        const left = target.getBoundingClientRect().left;
        const width = parseInt(column.columnWidth, 10) + (left - this.dragStartLeft);
        const columnWidth = Math.max(width || 0, minColumnWidth);
        column.columnWidth = coerceCssPixelValue(columnWidth);
        if (this.gantt.table) {
            this.gantt.table.columnChanges.emit({ columns: this.columnList });
        }
        this.hideAuxiliaryLine();
        event.source.reset();
    }
    tableDragEnded(event) {
        const target = event.source.element.nativeElement;
        const left = target.getBoundingClientRect().left;
        const tableWidth = this.elementRef.nativeElement.getBoundingClientRect().width;
        const dragWidth = left - this.dragStartLeft;
        this.columnList.forEach((column) => {
            const lastColumnWidth = parseInt(column.columnWidth, 10);
            const distributeWidth = parseInt(String(dragWidth * (lastColumnWidth / tableWidth)), 10);
            const columnWidth = Math.max(lastColumnWidth + distributeWidth || 0, minColumnWidth);
            column.columnWidth = coerceCssPixelValue(columnWidth);
        });
        if (this.gantt.table) {
            this.gantt.table.columnChanges.emit({ columns: this.columnList });
        }
        this.hideAuxiliaryLine();
        event.source.reset();
    }
    showAuxiliaryLine(event) {
        const tableRect = this.elementRef.nativeElement.getBoundingClientRect();
        this.draglineElementRef.nativeElement.style.left = `${event.event.clientX - tableRect.left}px`;
        this.draglineElementRef.nativeElement.style.display = 'block';
    }
    hideAuxiliaryLine() {
        this.draglineElementRef.nativeElement.style.display = 'none';
    }
    trackBy(index, item) {
        return item.id || index;
    }
}
GanttTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.9", ngImport: i0, type: GanttTableComponent, deps: [{ token: GANTT_ABSTRACT_TOKEN }, { token: GANTT_UPPER_TOKEN }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
GanttTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.9", type: GanttTableComponent, selector: "gantt-table", inputs: { groups: "groups", items: "items", columns: "columns", groupTemplate: "groupTemplate", emptyTemplate: "emptyTemplate", rowBeforeTemplate: "rowBeforeTemplate", rowAfterTemplate: "rowAfterTemplate" }, outputs: { itemClick: "itemClick" }, host: { properties: { "class.gantt-table": "this.ganttTableClass", "class.gantt-table-empty": "this.ganttTableEmptyClass" } }, viewQueries: [{ propertyName: "draglineElementRef", first: true, predicate: ["dragLine"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"gantt-table-header gantt-table-row\">\n  <div class=\"gantt-table-column\" *ngFor=\"let column of columnList; let i = index\" [style.width]=\"column.columnWidth\">\n    <ng-container *ngIf=\"column.headerTemplateRef; else default\" [ngTemplateOutlet]=\"column.headerTemplateRef\"></ng-container>\n    <ng-template #default>\n      {{ column.name }}\n    </ng-template>\n    <div\n      class=\"gantt-table-drag-trigger\"\n      cdkDrag\n      cdkDragLockAxis=\"x\"\n      cdkDragBoundary=\".gantt\"\n      (cdkDragMoved)=\"dragMoved($event, column)\"\n      (cdkDragStarted)=\"dragStarted($event)\"\n      (cdkDragEnded)=\"columnDragEnded($event, column)\"\n    ></div>\n  </div>\n</div>\n<div class=\"gantt-table-body\">\n  <ng-container *ngIf=\"!groups.length && !items.length\">\n    <ng-container *ngIf=\"!emptyTemplate\">\n      <gantt-icon class=\"empty-icon\" iconName=\"empty\"></gantt-icon>\n      <div class=\"empty-text\">\u6CA1\u6709\u6570\u636E</div>\n    </ng-container>\n    <ng-template [ngTemplateOutlet]=\"emptyTemplate\"></ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"groups && groups.length > 0; else itemsTemplate\">\n    <ng-container *ngFor=\"let group of groups; trackBy: trackBy\">\n      <div class=\"gantt-table-group\" [ngClass]=\"group.class\">\n        <div class=\"gantt-table-group-title\" [class.expanded]=\"group.expanded\" (click)=\"expandGroup(group)\">\n          <gantt-icon class=\"expand-icon\" [iconName]=\"group.expanded ? 'angle-down' : 'angle-right'\"></gantt-icon>\n          <ng-container *ngIf=\"groupTemplate; else default\">\n            <ng-template\n              [ngTemplateOutlet]=\"groupTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: group.origin, group: group.origin }\"\n            ></ng-template>\n          </ng-container>\n          <ng-template #default>\n            <span class=\"group-title\">{{ group.title }}</span>\n          </ng-template>\n        </div>\n      </div>\n\n      <ng-container *ngIf=\"group.expanded\">\n        <ng-template\n          [ngTemplateOutlet]=\"ganttItems\"\n          [ngTemplateOutletContext]=\"{ group: group, items: group.items, level: 0 }\"\n        ></ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<div\n  class=\"gantt-table-drag-trigger\"\n  cdkDrag\n  cdkDragLockAxis=\"x\"\n  cdkDragBoundary=\".gantt\"\n  (cdkDragMoved)=\"dragMoved($event)\"\n  (cdkDragStarted)=\"dragStarted($event)\"\n  (cdkDragEnded)=\"tableDragEnded($event)\"\n></div>\n\n<div #dragLine class=\"gantt-table-drag-auxiliary-line\"></div>\n\n<ng-template #itemsTemplate>\n  <ng-template [ngTemplateOutlet]=\"ganttItems\" [ngTemplateOutletContext]=\"{ items: items, level: 0 }\"></ng-template>\n</ng-template>\n\n<ng-template #ganttItems let-group=\"group\" let-items=\"items\" let-level=\"level\">\n  <ng-container *ngFor=\"let item of items; trackBy: trackBy\">\n    <div\n      (click)=\"itemClick.emit({ event: $event, selectedValue: this.item.origin })\"\n      class=\"gantt-table-item gantt-table-row\"\n      [class.gantt-table-item-first-level-group]=\"level === 0 && (item.type | isGanttRangeItem)\"\n      [class.gantt-table-item-with-group]=\"group\"\n      [class.gantt-table-item-active]=\"ganttUpper.isSelected(item.id)\"\n      [style.height.px]=\"gantt.styles.lineHeight\"\n      [style.lineHeight.px]=\"gantt.styles.lineHeight\"\n    >\n      <ng-template\n        [ngTemplateOutlet]=\"rowBeforeTemplate\"\n        [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n      ></ng-template>\n      <div class=\"gantt-table-column\" *ngFor=\"let column of columnList; let first = first\" [style.width]=\"column.columnWidth\">\n        <div *ngIf=\"first\" class=\"gantt-expand-icon\" [style.marginLeft.px]=\"level * 20\">\n          <ng-container *ngIf=\"level < gantt.maxLevel - 1 && item.expandable\">\n            <gantt-icon\n              *ngIf=\"!item.loading\"\n              class=\"expand-icon\"\n              [iconName]=\"item.expanded ? 'angle-down' : 'angle-right'\"\n              (click)=\"expandChildren($event, item)\"\n            ></gantt-icon>\n            <gantt-icon *ngIf=\"item.loading\" [iconName]=\"'loading'\"></gantt-icon>\n          </ng-container>\n        </div>\n        <div class=\"gantt-table-column-content\">\n          <ng-template\n            [ngTemplateOutlet]=\"column.templateRef\"\n            [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n          ></ng-template>\n        </div>\n      </div>\n      <ng-template\n        [ngTemplateOutlet]=\"rowAfterTemplate\"\n        [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n      ></ng-template>\n    </div>\n    <ng-template\n      *ngIf=\"item.children && item.expanded\"\n      [ngTemplateOutlet]=\"ganttItems\"\n      [ngTemplateOutletContext]=\"{ items: item.children, level: level + 1, group: group }\"\n    ></ng-template>\n  </ng-container>\n</ng-template>\n", components: [{ type: i1.GanttIconComponent, selector: "gantt-icon", inputs: ["iconName"] }], directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "isGanttRangeItem": i4.IsGanttRangeItemPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.9", ngImport: i0, type: GanttTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gantt-table', template: "<div class=\"gantt-table-header gantt-table-row\">\n  <div class=\"gantt-table-column\" *ngFor=\"let column of columnList; let i = index\" [style.width]=\"column.columnWidth\">\n    <ng-container *ngIf=\"column.headerTemplateRef; else default\" [ngTemplateOutlet]=\"column.headerTemplateRef\"></ng-container>\n    <ng-template #default>\n      {{ column.name }}\n    </ng-template>\n    <div\n      class=\"gantt-table-drag-trigger\"\n      cdkDrag\n      cdkDragLockAxis=\"x\"\n      cdkDragBoundary=\".gantt\"\n      (cdkDragMoved)=\"dragMoved($event, column)\"\n      (cdkDragStarted)=\"dragStarted($event)\"\n      (cdkDragEnded)=\"columnDragEnded($event, column)\"\n    ></div>\n  </div>\n</div>\n<div class=\"gantt-table-body\">\n  <ng-container *ngIf=\"!groups.length && !items.length\">\n    <ng-container *ngIf=\"!emptyTemplate\">\n      <gantt-icon class=\"empty-icon\" iconName=\"empty\"></gantt-icon>\n      <div class=\"empty-text\">\u6CA1\u6709\u6570\u636E</div>\n    </ng-container>\n    <ng-template [ngTemplateOutlet]=\"emptyTemplate\"></ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"groups && groups.length > 0; else itemsTemplate\">\n    <ng-container *ngFor=\"let group of groups; trackBy: trackBy\">\n      <div class=\"gantt-table-group\" [ngClass]=\"group.class\">\n        <div class=\"gantt-table-group-title\" [class.expanded]=\"group.expanded\" (click)=\"expandGroup(group)\">\n          <gantt-icon class=\"expand-icon\" [iconName]=\"group.expanded ? 'angle-down' : 'angle-right'\"></gantt-icon>\n          <ng-container *ngIf=\"groupTemplate; else default\">\n            <ng-template\n              [ngTemplateOutlet]=\"groupTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: group.origin, group: group.origin }\"\n            ></ng-template>\n          </ng-container>\n          <ng-template #default>\n            <span class=\"group-title\">{{ group.title }}</span>\n          </ng-template>\n        </div>\n      </div>\n\n      <ng-container *ngIf=\"group.expanded\">\n        <ng-template\n          [ngTemplateOutlet]=\"ganttItems\"\n          [ngTemplateOutletContext]=\"{ group: group, items: group.items, level: 0 }\"\n        ></ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<div\n  class=\"gantt-table-drag-trigger\"\n  cdkDrag\n  cdkDragLockAxis=\"x\"\n  cdkDragBoundary=\".gantt\"\n  (cdkDragMoved)=\"dragMoved($event)\"\n  (cdkDragStarted)=\"dragStarted($event)\"\n  (cdkDragEnded)=\"tableDragEnded($event)\"\n></div>\n\n<div #dragLine class=\"gantt-table-drag-auxiliary-line\"></div>\n\n<ng-template #itemsTemplate>\n  <ng-template [ngTemplateOutlet]=\"ganttItems\" [ngTemplateOutletContext]=\"{ items: items, level: 0 }\"></ng-template>\n</ng-template>\n\n<ng-template #ganttItems let-group=\"group\" let-items=\"items\" let-level=\"level\">\n  <ng-container *ngFor=\"let item of items; trackBy: trackBy\">\n    <div\n      (click)=\"itemClick.emit({ event: $event, selectedValue: this.item.origin })\"\n      class=\"gantt-table-item gantt-table-row\"\n      [class.gantt-table-item-first-level-group]=\"level === 0 && (item.type | isGanttRangeItem)\"\n      [class.gantt-table-item-with-group]=\"group\"\n      [class.gantt-table-item-active]=\"ganttUpper.isSelected(item.id)\"\n      [style.height.px]=\"gantt.styles.lineHeight\"\n      [style.lineHeight.px]=\"gantt.styles.lineHeight\"\n    >\n      <ng-template\n        [ngTemplateOutlet]=\"rowBeforeTemplate\"\n        [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n      ></ng-template>\n      <div class=\"gantt-table-column\" *ngFor=\"let column of columnList; let first = first\" [style.width]=\"column.columnWidth\">\n        <div *ngIf=\"first\" class=\"gantt-expand-icon\" [style.marginLeft.px]=\"level * 20\">\n          <ng-container *ngIf=\"level < gantt.maxLevel - 1 && item.expandable\">\n            <gantt-icon\n              *ngIf=\"!item.loading\"\n              class=\"expand-icon\"\n              [iconName]=\"item.expanded ? 'angle-down' : 'angle-right'\"\n              (click)=\"expandChildren($event, item)\"\n            ></gantt-icon>\n            <gantt-icon *ngIf=\"item.loading\" [iconName]=\"'loading'\"></gantt-icon>\n          </ng-container>\n        </div>\n        <div class=\"gantt-table-column-content\">\n          <ng-template\n            [ngTemplateOutlet]=\"column.templateRef\"\n            [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n          ></ng-template>\n        </div>\n      </div>\n      <ng-template\n        [ngTemplateOutlet]=\"rowAfterTemplate\"\n        [ngTemplateOutletContext]=\"{ $implicit: item.origin, item: item.origin }\"\n      ></ng-template>\n    </div>\n    <ng-template\n      *ngIf=\"item.children && item.expanded\"\n      [ngTemplateOutlet]=\"ganttItems\"\n      [ngTemplateOutletContext]=\"{ items: item.children, level: level + 1, group: group }\"\n    ></ng-template>\n  </ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [GANTT_ABSTRACT_TOKEN]
                }] }, { type: i5.GanttUpper, decorators: [{
                    type: Inject,
                    args: [GANTT_UPPER_TOKEN]
                }] }, { type: i0.ElementRef }]; }, propDecorators: { groups: [{
                type: Input
            }], items: [{
                type: Input
            }], columns: [{
                type: Input
            }], groupTemplate: [{
                type: Input
            }], emptyTemplate: [{
                type: Input
            }], rowBeforeTemplate: [{
                type: Input
            }], rowAfterTemplate: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], draglineElementRef: [{
                type: ViewChild,
                args: ['dragLine', { static: true }]
            }], ganttTableClass: [{
                type: HostBinding,
                args: ['class.gantt-table']
            }], ganttTableEmptyClass: [{
                type: HostBinding,
                args: ['class.gantt-table-empty']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FudHQtdGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvZ2FudHQvc3JjL2NvbXBvbmVudHMvdGFibGUvZ2FudHQtdGFibGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvZ2FudHQvc3JjL2NvbXBvbmVudHMvdGFibGUvZ2FudHQtdGFibGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxXQUFXLEVBR1gsS0FBSyxFQUNMLFNBQVMsRUFJVCxNQUFNLEVBQ04sTUFBTSxFQUNOLFlBQVksRUFDZixNQUFNLGVBQWUsQ0FBQztBQUt2QixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQTBCLG9CQUFvQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDcEYsT0FBTyxFQUFjLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sMENBQTBDLENBQUM7Ozs7Ozs7QUFFcEYsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsR0FBRyxDQUFDO0FBQ3RDLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFZakMsTUFBTSxPQUFPLG1CQUFtQjtJQW1DNUIsWUFDeUMsS0FBNkIsRUFDaEMsVUFBc0IsRUFDaEQsVUFBc0I7UUFGTyxVQUFLLEdBQUwsS0FBSyxDQUF3QjtRQUNoQyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ2hELGVBQVUsR0FBVixVQUFVLENBQVk7UUFYeEIsY0FBUyxHQUFHLElBQUksWUFBWSxFQUFzQixDQUFDO1FBSTNCLG9CQUFlLEdBQUcsSUFBSSxDQUFDO1FBRWpCLHlCQUFvQixHQUFHLEtBQUssQ0FBQztJQU1sRSxDQUFDO0lBOUJKLElBQ0ksT0FBTyxDQUFDLE9BQWdE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YUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0lBQ2pFLENBQUM7SUFFRCxPQUFPLENBQUMsS0FBYSxFQUFFLElBQTRDO1FBQy9ELE9BQU8sSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUM7SUFDNUIsQ0FBQzs7Z0hBbEpRLG1CQUFtQixrQkFvQ2hCLG9CQUFvQixhQUNwQixpQkFBaUI7b0dBckNwQixtQkFBbUIsMGpCQ3BDaEMsODVKQW1IQTsyRkQvRWEsbUJBQW1CO2tCQUovQixTQUFTOytCQUNJLGFBQWE7OzBCQXVDbEIsTUFBTTsyQkFBQyxvQkFBb0I7OzBCQUMzQixNQUFNOzJCQUFDLGlCQUFpQjtxRUFoQ3BCLE1BQU07c0JBQWQsS0FBSztnQkFFRyxLQUFLO3NCQUFiLEtBQUs7Z0JBR0YsT0FBTztzQkFEVixLQUFLO2dCQVVHLGFBQWE7c0JBQXJCLEtBQUs7Z0JBRUcsYUFBYTtzQkFBckIsS0FBSztnQkFFRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBRUcsZ0JBQWdCO3NCQUF4QixLQUFLO2dCQUVJLFNBQVM7c0JBQWxCLE1BQU07Z0JBRWtDLGtCQUFrQjtzQkFBMUQsU0FBUzt1QkFBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUVMLGVBQWU7c0JBQWhELFdBQVc7dUJBQUMsbUJBQW1CO2dCQUVRLG9CQUFvQjtzQkFBM0QsV0FBVzt1QkFBQyx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBIb3N0QmluZGluZyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBRdWVyeUxpc3QsXG4gICAgSW5wdXQsXG4gICAgVmlld0NoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgT25DaGFuZ2VzLFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgSW5qZWN0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHYW50dEl0ZW1JbnRlcm5hbCwgR2FudHRHcm91cEludGVybmFsLCBHYW50dFNlbGVjdGVkRXZlbnQgfSBmcm9tICcuLi8uLi9jbGFzcyc7XG5pbXBvcnQgeyBOZ3hHYW50dFRhYmxlQ29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vdGFibGUvZ2FudHQtY29sdW1uLmNvbXBvbmVudCc7XG4vLyBpbXBvcnQgeyBkZWZhdWx0Q29sdW1uV2lkdGgsIG1pbkNvbHVtbldpZHRoIH0gZnJvbSAnLi4vLi4vZ2FudHQuY29tcG9uZW50JztcbmltcG9ydCB7IENka0RyYWdFbmQsIENka0RyYWdNb3ZlLCBDZGtEcmFnU3RhcnQgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7IGNvZXJjZUNzc1BpeGVsVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgR2FudHRBYnN0cmFjdENvbXBvbmVudCwgR0FOVFRfQUJTVFJBQ1RfVE9LRU4gfSBmcm9tICcuLi8uLi9nYW50dC1hYnN0cmFjdCc7XG5pbXBvcnQgeyBHYW50dFVwcGVyLCBHQU5UVF9VUFBFUl9UT0tFTiB9IGZyb20gJy4uLy4uL2dhbnR0LXVwcGVyJztcbmltcG9ydCB7IHNldFN0eWxlV2l0aFZlbmRvclByZWZpeCB9IGZyb20gJy4uLy4uL3V0aWxzL3NldC1zdHlsZS13aXRoLXZlbmRvci1wcmVmaXgnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbHVtbldpZHRoID0gMTAwO1xuZXhwb3J0IGNvbnN0IG1pbkNvbHVtbldpZHRoID0gODA7XG5cbmludGVyZmFjZSBEcmFnRml4ZWRDb25maWcge1xuICAgIHRhcmdldDogSFRNTEVsZW1lbnQ7XG4gICAgb3JpZ2luV2lkdGg6IG51bWJlcjtcbiAgICBtb3ZlZFdpZHRoOiBudW1iZXI7XG4gICAgbWluV2lkdGg6IG51bWJlcjtcbn1cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZ2FudHQtdGFibGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9nYW50dC10YWJsZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgR2FudHRUYWJsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gICAgcHVibGljIGNvbHVtbkxpc3Q6IFF1ZXJ5TGlzdDxOZ3hHYW50dFRhYmxlQ29sdW1uQ29tcG9uZW50PjtcblxuICAgIHB1YmxpYyBkcmFnU3RhcnRMZWZ0OiBudW1iZXI7XG5cbiAgICBASW5wdXQoKSBncm91cHM6IEdhbnR0R3JvdXBJbnRlcm5hbFtdO1xuXG4gICAgQElucHV0KCkgaXRlbXM6IEdhbnR0SXRlbUludGVybmFsW107XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBjb2x1bW5zKGNvbHVtbnM6IFF1ZXJ5TGlzdDxOZ3hHYW50dFRhYmxlQ29sdW1uQ29tcG9uZW50Pikge1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb2x1bW4uY29sdW1uV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4uY29sdW1uV2lkdGggPSBjb2VyY2VDc3NQaXhlbFZhbHVlKGRlZmF1bHRDb2x1bW5XaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbHVtbkxpc3QgPSBjb2x1bW5zO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIGdyb3VwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBASW5wdXQoKSBlbXB0eVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KCkgcm93QmVmb3JlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBASW5wdXQoKSByb3dBZnRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQE91dHB1dCgpIGl0ZW1DbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8R2FudHRTZWxlY3RlZEV2ZW50PigpO1xuXG4gICAgQFZpZXdDaGlsZCgnZHJhZ0xpbmUnLCB7IHN0YXRpYzogdHJ1ZSB9KSBkcmFnbGluZUVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5nYW50dC10YWJsZScpIGdhbnR0VGFibGVDbGFzcyA9IHRydWU7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmdhbnR0LXRhYmxlLWVtcHR5JykgZ2FudHRUYWJsZUVtcHR5Q2xhc3MgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEdBTlRUX0FCU1RSQUNUX1RPS0VOKSBwdWJsaWMgZ2FudHQ6IEdhbnR0QWJzdHJhY3RDb21wb25lbnQsXG4gICAgICAgIEBJbmplY3QoR0FOVFRfVVBQRVJfVE9LRU4pIHB1YmxpYyBnYW50dFVwcGVyOiBHYW50dFVwcGVyLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWZcbiAgICApIHt9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5ncm91cHMuY3VycmVudFZhbHVlPy5sZW5ndGggJiYgIWNoYW5nZXMuaXRlbXMuY3VycmVudFZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FudHRUYWJsZUVtcHR5Q2xhc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nYW50dFRhYmxlRW1wdHlDbGFzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmFnRml4ZWQoY29uZmlnOiBEcmFnRml4ZWRDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5tb3ZlZFdpZHRoIDwgY29uZmlnLm1pbldpZHRoKSB7XG4gICAgICAgICAgICBzZXRTdHlsZVdpdGhWZW5kb3JQcmVmaXgoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNvbmZpZy50YXJnZXQsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgdHJhbnNsYXRlM2QoJHtjb25maWcubWluV2lkdGggLSBjb25maWcub3JpZ2luV2lkdGh9cHgsIDAsIDApYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBhbmRHcm91cChncm91cDogR2FudHRHcm91cEludGVybmFsKSB7XG4gICAgICAgIHRoaXMuZ2FudHQuZXhwYW5kR3JvdXAoZ3JvdXApO1xuICAgIH1cblxuICAgIGV4cGFuZENoaWxkcmVuKGV2ZW50OiBNb3VzZUV2ZW50LCBpdGVtOiBHYW50dEl0ZW1JbnRlcm5hbCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5nYW50dC5leHBhbmRDaGlsZHJlbihpdGVtKTtcbiAgICB9XG5cbiAgICBkcmFnU3RhcnRlZChldmVudDogQ2RrRHJhZ1N0YXJ0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnNvdXJjZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0TGVmdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH1cblxuICAgIGRyYWdNb3ZlZChldmVudDogQ2RrRHJhZ01vdmUsIGNvbHVtbj86IE5neEdhbnR0VGFibGVDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuc291cmNlLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgbGVmdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXG4gICAgICAgIGxldCBvcmlnaW5XaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgbW92ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgbWluV2lkdGg6IG51bWJlcjtcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgb3JpZ2luV2lkdGggPSBwYXJzZUludChjb2x1bW4uY29sdW1uV2lkdGgsIDEwKTtcbiAgICAgICAgICAgIG1vdmVkV2lkdGggPSBvcmlnaW5XaWR0aCArIChsZWZ0IC0gdGhpcy5kcmFnU3RhcnRMZWZ0KTtcbiAgICAgICAgICAgIG1pbldpZHRoID0gbWluQ29sdW1uV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgbW92ZWRXaWR0aCA9IG9yaWdpbldpZHRoICsgKGxlZnQgLSB0aGlzLmRyYWdTdGFydExlZnQpO1xuICAgICAgICAgICAgbWluV2lkdGggPSBtaW5Db2x1bW5XaWR0aCAqIHRoaXMuY29sdW1uTGlzdC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdGaXhlZCh7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCxcbiAgICAgICAgICAgIG1vdmVkV2lkdGgsXG4gICAgICAgICAgICBtaW5XaWR0aFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNob3dBdXhpbGlhcnlMaW5lKGV2ZW50KTtcbiAgICB9XG5cbiAgICBjb2x1bW5EcmFnRW5kZWQoZXZlbnQ6IENka0RyYWdFbmQsIGNvbHVtbjogTmd4R2FudHRUYWJsZUNvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC5zb3VyY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoY29sdW1uLmNvbHVtbldpZHRoLCAxMCkgKyAobGVmdCAtIHRoaXMuZHJhZ1N0YXJ0TGVmdCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbldpZHRoID0gTWF0aC5tYXgod2lkdGggfHwgMCwgbWluQ29sdW1uV2lkdGgpO1xuICAgICAgICBjb2x1bW4uY29sdW1uV2lkdGggPSBjb2VyY2VDc3NQaXhlbFZhbHVlKGNvbHVtbldpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2FudHQudGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FudHQudGFibGUuY29sdW1uQ2hhbmdlcy5lbWl0KHsgY29sdW1uczogdGhpcy5jb2x1bW5MaXN0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRlQXV4aWxpYXJ5TGluZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UucmVzZXQoKTtcbiAgICB9XG5cbiAgICB0YWJsZURyYWdFbmRlZChldmVudDogQ2RrRHJhZ0VuZCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC5zb3VyY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHRhYmxlV2lkdGggPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgZHJhZ1dpZHRoID0gbGVmdCAtIHRoaXMuZHJhZ1N0YXJ0TGVmdDtcbiAgICAgICAgdGhpcy5jb2x1bW5MaXN0LmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbHVtbldpZHRoID0gcGFyc2VJbnQoY29sdW1uLmNvbHVtbldpZHRoLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0cmlidXRlV2lkdGggPSBwYXJzZUludChTdHJpbmcoZHJhZ1dpZHRoICogKGxhc3RDb2x1bW5XaWR0aCAvIHRhYmxlV2lkdGgpKSwgMTApO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBNYXRoLm1heChsYXN0Q29sdW1uV2lkdGggKyBkaXN0cmlidXRlV2lkdGggfHwgMCwgbWluQ29sdW1uV2lkdGgpO1xuICAgICAgICAgICAgY29sdW1uLmNvbHVtbldpZHRoID0gY29lcmNlQ3NzUGl4ZWxWYWx1ZShjb2x1bW5XaWR0aCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmdhbnR0LnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmdhbnR0LnRhYmxlLmNvbHVtbkNoYW5nZXMuZW1pdCh7IGNvbHVtbnM6IHRoaXMuY29sdW1uTGlzdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGlkZUF1eGlsaWFyeUxpbmUoKTtcbiAgICAgICAgZXZlbnQuc291cmNlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG93QXV4aWxpYXJ5TGluZShldmVudDogQ2RrRHJhZ01vdmUpIHtcbiAgICAgICAgY29uc3QgdGFibGVSZWN0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuZHJhZ2xpbmVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGAkeyhldmVudC5ldmVudCBhcyBhbnkpLmNsaWVudFggLSB0YWJsZVJlY3QubGVmdH1weGA7XG4gICAgICAgIHRoaXMuZHJhZ2xpbmVFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoaWRlQXV4aWxpYXJ5TGluZSgpIHtcbiAgICAgICAgdGhpcy5kcmFnbGluZUVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHRyYWNrQnkoaW5kZXg6IG51bWJlciwgaXRlbTogR2FudHRHcm91cEludGVybmFsIHwgR2FudHRJdGVtSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaWQgfHwgaW5kZXg7XG4gICAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImdhbnR0LXRhYmxlLWhlYWRlciBnYW50dC10YWJsZS1yb3dcIj5cbiAgPGRpdiBjbGFzcz1cImdhbnR0LXRhYmxlLWNvbHVtblwiICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uTGlzdDsgbGV0IGkgPSBpbmRleFwiIFtzdHlsZS53aWR0aF09XCJjb2x1bW4uY29sdW1uV2lkdGhcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmOyBlbHNlIGRlZmF1bHRcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4uaGVhZGVyVGVtcGxhdGVSZWZcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHQ+XG4gICAgICB7eyBjb2x1bW4ubmFtZSB9fVxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPGRpdlxuICAgICAgY2xhc3M9XCJnYW50dC10YWJsZS1kcmFnLXRyaWdnZXJcIlxuICAgICAgY2RrRHJhZ1xuICAgICAgY2RrRHJhZ0xvY2tBeGlzPVwieFwiXG4gICAgICBjZGtEcmFnQm91bmRhcnk9XCIuZ2FudHRcIlxuICAgICAgKGNka0RyYWdNb3ZlZCk9XCJkcmFnTW92ZWQoJGV2ZW50LCBjb2x1bW4pXCJcbiAgICAgIChjZGtEcmFnU3RhcnRlZCk9XCJkcmFnU3RhcnRlZCgkZXZlbnQpXCJcbiAgICAgIChjZGtEcmFnRW5kZWQpPVwiY29sdW1uRHJhZ0VuZGVkKCRldmVudCwgY29sdW1uKVwiXG4gICAgPjwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImdhbnR0LXRhYmxlLWJvZHlcIj5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFncm91cHMubGVuZ3RoICYmICFpdGVtcy5sZW5ndGhcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWVtcHR5VGVtcGxhdGVcIj5cbiAgICAgIDxnYW50dC1pY29uIGNsYXNzPVwiZW1wdHktaWNvblwiIGljb25OYW1lPVwiZW1wdHlcIj48L2dhbnR0LWljb24+XG4gICAgICA8ZGl2IGNsYXNzPVwiZW1wdHktdGV4dFwiPuayoeacieaVsOaNrjwvZGl2PlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJlbXB0eVRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyb3VwcyAmJiBncm91cHMubGVuZ3RoID4gMDsgZWxzZSBpdGVtc1RlbXBsYXRlXCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgZ3JvdXAgb2YgZ3JvdXBzOyB0cmFja0J5OiB0cmFja0J5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZ2FudHQtdGFibGUtZ3JvdXBcIiBbbmdDbGFzc109XCJncm91cC5jbGFzc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FudHQtdGFibGUtZ3JvdXAtdGl0bGVcIiBbY2xhc3MuZXhwYW5kZWRdPVwiZ3JvdXAuZXhwYW5kZWRcIiAoY2xpY2spPVwiZXhwYW5kR3JvdXAoZ3JvdXApXCI+XG4gICAgICAgICAgPGdhbnR0LWljb24gY2xhc3M9XCJleHBhbmQtaWNvblwiIFtpY29uTmFtZV09XCJncm91cC5leHBhbmRlZCA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCdcIj48L2dhbnR0LWljb24+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyb3VwVGVtcGxhdGU7IGVsc2UgZGVmYXVsdFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImdyb3VwVGVtcGxhdGVcIlxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IGdyb3VwLm9yaWdpbiwgZ3JvdXA6IGdyb3VwLm9yaWdpbiB9XCJcbiAgICAgICAgICAgID48L25nLXRlbXBsYXRlPlxuICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ3JvdXAtdGl0bGVcIj57eyBncm91cC50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZ3JvdXAuZXhwYW5kZWRcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiZ2FudHRJdGVtc1wiXG4gICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgZ3JvdXA6IGdyb3VwLCBpdGVtczogZ3JvdXAuaXRlbXMsIGxldmVsOiAwIH1cIlxuICAgICAgICA+PC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48ZGl2XG4gIGNsYXNzPVwiZ2FudHQtdGFibGUtZHJhZy10cmlnZ2VyXCJcbiAgY2RrRHJhZ1xuICBjZGtEcmFnTG9ja0F4aXM9XCJ4XCJcbiAgY2RrRHJhZ0JvdW5kYXJ5PVwiLmdhbnR0XCJcbiAgKGNka0RyYWdNb3ZlZCk9XCJkcmFnTW92ZWQoJGV2ZW50KVwiXG4gIChjZGtEcmFnU3RhcnRlZCk9XCJkcmFnU3RhcnRlZCgkZXZlbnQpXCJcbiAgKGNka0RyYWdFbmRlZCk9XCJ0YWJsZURyYWdFbmRlZCgkZXZlbnQpXCJcbj48L2Rpdj5cblxuPGRpdiAjZHJhZ0xpbmUgY2xhc3M9XCJnYW50dC10YWJsZS1kcmFnLWF1eGlsaWFyeS1saW5lXCI+PC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjaXRlbXNUZW1wbGF0ZT5cbiAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImdhbnR0SXRlbXNcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyBpdGVtczogaXRlbXMsIGxldmVsOiAwIH1cIj48L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNnYW50dEl0ZW1zIGxldC1ncm91cD1cImdyb3VwXCIgbGV0LWl0ZW1zPVwiaXRlbXNcIiBsZXQtbGV2ZWw9XCJsZXZlbFwiPlxuICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyB0cmFja0J5OiB0cmFja0J5XCI+XG4gICAgPGRpdlxuICAgICAgKGNsaWNrKT1cIml0ZW1DbGljay5lbWl0KHsgZXZlbnQ6ICRldmVudCwgc2VsZWN0ZWRWYWx1ZTogdGhpcy5pdGVtLm9yaWdpbiB9KVwiXG4gICAgICBjbGFzcz1cImdhbnR0LXRhYmxlLWl0ZW0gZ2FudHQtdGFibGUtcm93XCJcbiAgICAgIFtjbGFzcy5nYW50dC10YWJsZS1pdGVtLWZpcnN0LWxldmVsLWdyb3VwXT1cImxldmVsID09PSAwICYmIChpdGVtLnR5cGUgfCBpc0dhbnR0UmFuZ2VJdGVtKVwiXG4gICAgICBbY2xhc3MuZ2FudHQtdGFibGUtaXRlbS13aXRoLWdyb3VwXT1cImdyb3VwXCJcbiAgICAgIFtjbGFzcy5nYW50dC10YWJsZS1pdGVtLWFjdGl2ZV09XCJnYW50dFVwcGVyLmlzU2VsZWN0ZWQoaXRlbS5pZClcIlxuICAgICAgW3N0eWxlLmhlaWdodC5weF09XCJnYW50dC5zdHlsZXMubGluZUhlaWdodFwiXG4gICAgICBbc3R5bGUubGluZUhlaWdodC5weF09XCJnYW50dC5zdHlsZXMubGluZUhlaWdodFwiXG4gICAgPlxuICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJvd0JlZm9yZVRlbXBsYXRlXCJcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiBpdGVtLm9yaWdpbiwgaXRlbTogaXRlbS5vcmlnaW4gfVwiXG4gICAgICA+PC9uZy10ZW1wbGF0ZT5cbiAgICAgIDxkaXYgY2xhc3M9XCJnYW50dC10YWJsZS1jb2x1bW5cIiAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbkxpc3Q7IGxldCBmaXJzdCA9IGZpcnN0XCIgW3N0eWxlLndpZHRoXT1cImNvbHVtbi5jb2x1bW5XaWR0aFwiPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiZmlyc3RcIiBjbGFzcz1cImdhbnR0LWV4cGFuZC1pY29uXCIgW3N0eWxlLm1hcmdpbkxlZnQucHhdPVwibGV2ZWwgKiAyMFwiPlxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsZXZlbCA8IGdhbnR0Lm1heExldmVsIC0gMSAmJiBpdGVtLmV4cGFuZGFibGVcIj5cbiAgICAgICAgICAgIDxnYW50dC1pY29uXG4gICAgICAgICAgICAgICpuZ0lmPVwiIWl0ZW0ubG9hZGluZ1wiXG4gICAgICAgICAgICAgIGNsYXNzPVwiZXhwYW5kLWljb25cIlxuICAgICAgICAgICAgICBbaWNvbk5hbWVdPVwiaXRlbS5leHBhbmRlZCA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCdcIlxuICAgICAgICAgICAgICAoY2xpY2spPVwiZXhwYW5kQ2hpbGRyZW4oJGV2ZW50LCBpdGVtKVwiXG4gICAgICAgICAgICA+PC9nYW50dC1pY29uPlxuICAgICAgICAgICAgPGdhbnR0LWljb24gKm5nSWY9XCJpdGVtLmxvYWRpbmdcIiBbaWNvbk5hbWVdPVwiJ2xvYWRpbmcnXCI+PC9nYW50dC1pY29uPlxuICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImdhbnR0LXRhYmxlLWNvbHVtbi1jb250ZW50XCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiBpdGVtLm9yaWdpbiwgaXRlbTogaXRlbS5vcmlnaW4gfVwiXG4gICAgICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwicm93QWZ0ZXJUZW1wbGF0ZVwiXG4gICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogaXRlbS5vcmlnaW4sIGl0ZW06IGl0ZW0ub3JpZ2luIH1cIlxuICAgICAgPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gICAgPG5nLXRlbXBsYXRlXG4gICAgICAqbmdJZj1cIml0ZW0uY2hpbGRyZW4gJiYgaXRlbS5leHBhbmRlZFwiXG4gICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJnYW50dEl0ZW1zXCJcbiAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7IGl0ZW1zOiBpdGVtLmNoaWxkcmVuLCBsZXZlbDogbGV2ZWwgKyAxLCBncm91cDogZ3JvdXAgfVwiXG4gICAgPjwvbmctdGVtcGxhdGU+XG4gIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==