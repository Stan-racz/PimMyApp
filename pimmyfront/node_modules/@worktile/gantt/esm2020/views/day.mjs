import { GanttView, primaryDatePointTop, secondaryDatePointTop } from './view';
import { GanttDate, eachWeekOfInterval, eachDayOfInterval } from '../utils/date';
import { GanttDatePoint } from '../class/date-point';
const viewOptions = {
    cellWidth: 35,
    start: new GanttDate().startOfYear().startOfWeek({ weekStartsOn: 1 }),
    end: new GanttDate().endOfYear().endOfWeek({ weekStartsOn: 1 }),
    addAmount: 1,
    addUnit: 'month'
};
export class GanttViewDay extends GanttView {
    constructor(start, end, options) {
        super(start, end, Object.assign({}, viewOptions, options));
        this.showWeekBackdrop = true;
        this.showTimeline = false;
    }
    startOf(date) {
        return date.startOfWeek({ weekStartsOn: 1 });
    }
    endOf(date) {
        return date.endOfWeek({ weekStartsOn: 1 });
    }
    getPrimaryWidth() {
        return this.getCellWidth() * 7;
    }
    getDayOccupancyWidth() {
        return this.cellWidth;
    }
    getPrimaryDatePoints() {
        const weeks = eachWeekOfInterval({ start: this.start.value, end: this.end.addSeconds(1).value }, { weekStartsOn: 1 });
        const points = [];
        for (let i = 0; i < weeks.length; i++) {
            const weekStart = new GanttDate(weeks[i]);
            const increaseWeek = weekStart.getDaysInMonth() - weekStart.getDate() >= 3 ? 0 : 1;
            const point = new GanttDatePoint(weekStart, weekStart.addWeeks(increaseWeek).format(this.options.dateFormat.yearMonth), (this.getCellWidth() * 7) / 2 + i * (this.getCellWidth() * 7), primaryDatePointTop);
            points.push(point);
        }
        return points;
    }
    getSecondaryDatePoints() {
        const days = eachDayOfInterval({ start: this.start.value, end: this.end.value });
        const points = [];
        for (let i = 0; i < days.length; i++) {
            const start = new GanttDate(days[i]);
            const point = new GanttDatePoint(start, start.getDate().toString(), i * this.getCellWidth() + this.getCellWidth() / 2, secondaryDatePointTop, {
                isWeekend: start.isWeekend(),
                isToday: start.isToday()
            });
            points.push(point);
        }
        return points;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcGFja2FnZXMvZ2FudHQvc3JjL3ZpZXdzL2RheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFvQixtQkFBbUIsRUFBRSxxQkFBcUIsRUFBaUIsTUFBTSxRQUFRLENBQUM7QUFDaEgsT0FBTyxFQUFFLFNBQVMsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFckQsTUFBTSxXQUFXLEdBQXFCO0lBQ2xDLFNBQVMsRUFBRSxFQUFFO0lBQ2IsS0FBSyxFQUFFLElBQUksU0FBUyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQ3JFLEdBQUcsRUFBRSxJQUFJLFNBQVMsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUMvRCxTQUFTLEVBQUUsQ0FBQztJQUNaLE9BQU8sRUFBRSxPQUFPO0NBQ25CLENBQUM7QUFFRixNQUFNLE9BQU8sWUFBYSxTQUFRLFNBQVM7SUFLdkMsWUFBWSxLQUFvQixFQUFFLEdBQWtCLEVBQUUsT0FBMEI7UUFDNUUsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFMdEQscUJBQWdCLEdBQUcsSUFBSSxDQUFDO1FBRXhCLGlCQUFZLEdBQUcsS0FBSyxDQUFDO0lBSTlCLENBQUM7SUFFRCxPQUFPLENBQUMsSUFBZTtRQUNuQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsS0FBSyxDQUFDLElBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELG9CQUFvQjtRQUNoQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVELG9CQUFvQjtRQUNoQixNQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0SCxNQUFNLE1BQU0sR0FBcUIsRUFBRSxDQUFDO1FBQ3BDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFDLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxjQUFjLEVBQUUsR0FBRyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRixNQUFNLEtBQUssR0FBRyxJQUFJLGNBQWMsQ0FDNUIsU0FBUyxFQUNULFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUMxRSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUM3RCxtQkFBbUIsQ0FDdEIsQ0FBQztZQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQsc0JBQXNCO1FBQ2xCLE1BQU0sSUFBSSxHQUFHLGlCQUFpQixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDakYsTUFBTSxNQUFNLEdBQXFCLEVBQUUsQ0FBQztRQUNwQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQyxNQUFNLEtBQUssR0FBRyxJQUFJLGNBQWMsQ0FDNUIsS0FBSyxFQUNMLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFDMUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxFQUNqRCxxQkFBcUIsRUFDckI7Z0JBQ0ksU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUU7Z0JBQzVCLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxFQUFFO2FBQzNCLENBQ0osQ0FBQztZQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW50dFZpZXcsIEdhbnR0Vmlld09wdGlvbnMsIHByaW1hcnlEYXRlUG9pbnRUb3AsIHNlY29uZGFyeURhdGVQb2ludFRvcCwgR2FudHRWaWV3RGF0ZSB9IGZyb20gJy4vdmlldyc7XG5pbXBvcnQgeyBHYW50dERhdGUsIGVhY2hXZWVrT2ZJbnRlcnZhbCwgZWFjaERheU9mSW50ZXJ2YWwgfSBmcm9tICcuLi91dGlscy9kYXRlJztcbmltcG9ydCB7IEdhbnR0RGF0ZVBvaW50IH0gZnJvbSAnLi4vY2xhc3MvZGF0ZS1wb2ludCc7XG5cbmNvbnN0IHZpZXdPcHRpb25zOiBHYW50dFZpZXdPcHRpb25zID0ge1xuICAgIGNlbGxXaWR0aDogMzUsXG4gICAgc3RhcnQ6IG5ldyBHYW50dERhdGUoKS5zdGFydE9mWWVhcigpLnN0YXJ0T2ZXZWVrKHsgd2Vla1N0YXJ0c09uOiAxIH0pLFxuICAgIGVuZDogbmV3IEdhbnR0RGF0ZSgpLmVuZE9mWWVhcigpLmVuZE9mV2Vlayh7IHdlZWtTdGFydHNPbjogMSB9KSxcbiAgICBhZGRBbW91bnQ6IDEsXG4gICAgYWRkVW5pdDogJ21vbnRoJ1xufTtcblxuZXhwb3J0IGNsYXNzIEdhbnR0Vmlld0RheSBleHRlbmRzIEdhbnR0VmlldyB7XG4gICAgb3ZlcnJpZGUgc2hvd1dlZWtCYWNrZHJvcCA9IHRydWU7XG5cbiAgICBvdmVycmlkZSBzaG93VGltZWxpbmUgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0OiBHYW50dFZpZXdEYXRlLCBlbmQ6IEdhbnR0Vmlld0RhdGUsIG9wdGlvbnM/OiBHYW50dFZpZXdPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0LCBlbmQsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdPcHRpb25zLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgc3RhcnRPZihkYXRlOiBHYW50dERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuc3RhcnRPZldlZWsoeyB3ZWVrU3RhcnRzT246IDEgfSk7XG4gICAgfVxuXG4gICAgZW5kT2YoZGF0ZTogR2FudHREYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmVuZE9mV2Vlayh7IHdlZWtTdGFydHNPbjogMSB9KTtcbiAgICB9XG5cbiAgICBnZXRQcmltYXJ5V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxXaWR0aCgpICogNztcbiAgICB9XG5cbiAgICBnZXREYXlPY2N1cGFuY3lXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsV2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0UHJpbWFyeURhdGVQb2ludHMoKTogR2FudHREYXRlUG9pbnRbXSB7XG4gICAgICAgIGNvbnN0IHdlZWtzID0gZWFjaFdlZWtPZkludGVydmFsKHsgc3RhcnQ6IHRoaXMuc3RhcnQudmFsdWUsIGVuZDogdGhpcy5lbmQuYWRkU2Vjb25kcygxKS52YWx1ZSB9LCB7IHdlZWtTdGFydHNPbjogMSB9KTtcbiAgICAgICAgY29uc3QgcG9pbnRzOiBHYW50dERhdGVQb2ludFtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2Vla3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtTdGFydCA9IG5ldyBHYW50dERhdGUod2Vla3NbaV0pO1xuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2VXZWVrID0gd2Vla1N0YXJ0LmdldERheXNJbk1vbnRoKCkgLSB3ZWVrU3RhcnQuZ2V0RGF0ZSgpID49IDMgPyAwIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEdhbnR0RGF0ZVBvaW50KFxuICAgICAgICAgICAgICAgIHdlZWtTdGFydCxcbiAgICAgICAgICAgICAgICB3ZWVrU3RhcnQuYWRkV2Vla3MoaW5jcmVhc2VXZWVrKS5mb3JtYXQodGhpcy5vcHRpb25zLmRhdGVGb3JtYXQueWVhck1vbnRoKSxcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRDZWxsV2lkdGgoKSAqIDcpIC8gMiArIGkgKiAodGhpcy5nZXRDZWxsV2lkdGgoKSAqIDcpLFxuICAgICAgICAgICAgICAgIHByaW1hcnlEYXRlUG9pbnRUb3BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBnZXRTZWNvbmRhcnlEYXRlUG9pbnRzKCk6IEdhbnR0RGF0ZVBvaW50W10ge1xuICAgICAgICBjb25zdCBkYXlzID0gZWFjaERheU9mSW50ZXJ2YWwoeyBzdGFydDogdGhpcy5zdGFydC52YWx1ZSwgZW5kOiB0aGlzLmVuZC52YWx1ZSB9KTtcbiAgICAgICAgY29uc3QgcG9pbnRzOiBHYW50dERhdGVQb2ludFtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgR2FudHREYXRlKGRheXNbaV0pO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgR2FudHREYXRlUG9pbnQoXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQuZ2V0RGF0ZSgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuZ2V0Q2VsbFdpZHRoKCkgKyB0aGlzLmdldENlbGxXaWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlEYXRlUG9pbnRUb3AsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpc1dlZWtlbmQ6IHN0YXJ0LmlzV2Vla2VuZCgpLFxuICAgICAgICAgICAgICAgICAgICBpc1RvZGF5OiBzdGFydC5pc1RvZGF5KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxufVxuIl19