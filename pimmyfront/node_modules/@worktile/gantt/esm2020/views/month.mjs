import { GanttView, primaryDatePointTop, secondaryDatePointTop } from './view';
import { GanttDate, differenceInCalendarQuarters, eachMonthOfInterval } from '../utils/date';
import { GanttDatePoint } from '../class/date-point';
const viewOptions = {
    start: new GanttDate().startOfQuarter().addQuarters(-1),
    end: new GanttDate().endOfQuarter().addQuarters(2),
    cellWidth: 280,
    addAmount: 1,
    addUnit: 'quarter'
};
export class GanttViewMonth extends GanttView {
    constructor(start, end, options) {
        super(start, end, Object.assign({}, viewOptions, options));
    }
    startOf(date) {
        return date.startOfQuarter();
    }
    endOf(date) {
        return date.endOfQuarter();
    }
    getPrimaryWidth() {
        return this.getCellWidth() * 3;
    }
    getDayOccupancyWidth(date) {
        return this.cellWidth / date.getDaysInMonth();
    }
    getPrimaryDatePoints() {
        const quarters = differenceInCalendarQuarters(this.end.addSeconds(1).value, this.start.value);
        const points = [];
        for (let i = 0; i < quarters; i++) {
            const start = this.start.addQuarters(i);
            const point = new GanttDatePoint(start, start.format(this.options.dateFormat.yearQuarter), (this.getCellWidth() * 3) / 2 + i * (this.getCellWidth() * 3), primaryDatePointTop);
            points.push(point);
        }
        return points;
    }
    getSecondaryDatePoints() {
        const months = eachMonthOfInterval({ start: this.start.value, end: this.end.value });
        const points = [];
        for (let i = 0; i < months.length; i++) {
            const start = new GanttDate(months[i]);
            const point = new GanttDatePoint(start, start.format(this.options.dateFormat.month), i * this.getCellWidth() + this.getCellWidth() / 2, secondaryDatePointTop);
            points.push(point);
        }
        return points;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy9nYW50dC9zcmMvdmlld3MvbW9udGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBb0IsbUJBQW1CLEVBQUUscUJBQXFCLEVBQWlCLE1BQU0sUUFBUSxDQUFDO0FBQ2hILE9BQU8sRUFBRSxTQUFTLEVBQUUsNEJBQTRCLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0YsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXJELE1BQU0sV0FBVyxHQUFxQjtJQUNsQyxLQUFLLEVBQUUsSUFBSSxTQUFTLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkQsR0FBRyxFQUFFLElBQUksU0FBUyxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUNsRCxTQUFTLEVBQUUsR0FBRztJQUNkLFNBQVMsRUFBRSxDQUFDO0lBQ1osT0FBTyxFQUFFLFNBQVM7Q0FDckIsQ0FBQztBQUVGLE1BQU0sT0FBTyxjQUFlLFNBQVEsU0FBUztJQUN6QyxZQUFZLEtBQW9CLEVBQUUsR0FBa0IsRUFBRSxPQUEwQjtRQUM1RSxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsT0FBTyxDQUFDLElBQWU7UUFDbkIsT0FBTyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVELEtBQUssQ0FBQyxJQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRCxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxJQUFlO1FBQ2hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDbEQsQ0FBQztJQUVELG9CQUFvQjtRQUNoQixNQUFNLFFBQVEsR0FBRyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5RixNQUFNLE1BQU0sR0FBcUIsRUFBRSxDQUFDO1FBQ3BDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxjQUFjLENBQzVCLEtBQUssRUFDTCxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUNqRCxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUM3RCxtQkFBbUIsQ0FDdEIsQ0FBQztZQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQsc0JBQXNCO1FBQ2xCLE1BQU0sTUFBTSxHQUFHLG1CQUFtQixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDckYsTUFBTSxNQUFNLEdBQXFCLEVBQUUsQ0FBQztRQUNwQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQyxNQUFNLEtBQUssR0FBRyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QyxNQUFNLEtBQUssR0FBRyxJQUFJLGNBQWMsQ0FDNUIsS0FBSyxFQUNMLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQzNDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsRUFDakQscUJBQXFCLENBQ3hCLENBQUM7WUFDRixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2FudHRWaWV3LCBHYW50dFZpZXdPcHRpb25zLCBwcmltYXJ5RGF0ZVBvaW50VG9wLCBzZWNvbmRhcnlEYXRlUG9pbnRUb3AsIEdhbnR0Vmlld0RhdGUgfSBmcm9tICcuL3ZpZXcnO1xuaW1wb3J0IHsgR2FudHREYXRlLCBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzLCBlYWNoTW9udGhPZkludGVydmFsIH0gZnJvbSAnLi4vdXRpbHMvZGF0ZSc7XG5pbXBvcnQgeyBHYW50dERhdGVQb2ludCB9IGZyb20gJy4uL2NsYXNzL2RhdGUtcG9pbnQnO1xuXG5jb25zdCB2aWV3T3B0aW9uczogR2FudHRWaWV3T3B0aW9ucyA9IHtcbiAgICBzdGFydDogbmV3IEdhbnR0RGF0ZSgpLnN0YXJ0T2ZRdWFydGVyKCkuYWRkUXVhcnRlcnMoLTEpLFxuICAgIGVuZDogbmV3IEdhbnR0RGF0ZSgpLmVuZE9mUXVhcnRlcigpLmFkZFF1YXJ0ZXJzKDIpLFxuICAgIGNlbGxXaWR0aDogMjgwLFxuICAgIGFkZEFtb3VudDogMSxcbiAgICBhZGRVbml0OiAncXVhcnRlcidcbn07XG5cbmV4cG9ydCBjbGFzcyBHYW50dFZpZXdNb250aCBleHRlbmRzIEdhbnR0VmlldyB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IEdhbnR0Vmlld0RhdGUsIGVuZDogR2FudHRWaWV3RGF0ZSwgb3B0aW9ucz86IEdhbnR0Vmlld09wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQsIGVuZCwgT2JqZWN0LmFzc2lnbih7fSwgdmlld09wdGlvbnMsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBzdGFydE9mKGRhdGU6IEdhbnR0RGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5zdGFydE9mUXVhcnRlcigpO1xuICAgIH1cblxuICAgIGVuZE9mKGRhdGU6IEdhbnR0RGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5lbmRPZlF1YXJ0ZXIoKTtcbiAgICB9XG5cbiAgICBnZXRQcmltYXJ5V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxXaWR0aCgpICogMztcbiAgICB9XG5cbiAgICBnZXREYXlPY2N1cGFuY3lXaWR0aChkYXRlOiBHYW50dERhdGUpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsV2lkdGggLyBkYXRlLmdldERheXNJbk1vbnRoKCk7XG4gICAgfVxuXG4gICAgZ2V0UHJpbWFyeURhdGVQb2ludHMoKTogR2FudHREYXRlUG9pbnRbXSB7XG4gICAgICAgIGNvbnN0IHF1YXJ0ZXJzID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycyh0aGlzLmVuZC5hZGRTZWNvbmRzKDEpLnZhbHVlLCB0aGlzLnN0YXJ0LnZhbHVlKTtcbiAgICAgICAgY29uc3QgcG9pbnRzOiBHYW50dERhdGVQb2ludFtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LmFkZFF1YXJ0ZXJzKGkpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgR2FudHREYXRlUG9pbnQoXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQuZm9ybWF0KHRoaXMub3B0aW9ucy5kYXRlRm9ybWF0LnllYXJRdWFydGVyKSxcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRDZWxsV2lkdGgoKSAqIDMpIC8gMiArIGkgKiAodGhpcy5nZXRDZWxsV2lkdGgoKSAqIDMpLFxuICAgICAgICAgICAgICAgIHByaW1hcnlEYXRlUG9pbnRUb3BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIGdldFNlY29uZGFyeURhdGVQb2ludHMoKTogR2FudHREYXRlUG9pbnRbXSB7XG4gICAgICAgIGNvbnN0IG1vbnRocyA9IGVhY2hNb250aE9mSW50ZXJ2YWwoeyBzdGFydDogdGhpcy5zdGFydC52YWx1ZSwgZW5kOiB0aGlzLmVuZC52YWx1ZSB9KTtcbiAgICAgICAgY29uc3QgcG9pbnRzOiBHYW50dERhdGVQb2ludFtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9udGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBHYW50dERhdGUobW9udGhzW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEdhbnR0RGF0ZVBvaW50KFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0LmZvcm1hdCh0aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdC5tb250aCksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuZ2V0Q2VsbFdpZHRoKCkgKyB0aGlzLmdldENlbGxXaWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlEYXRlUG9pbnRUb3BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG59XG4iXX0=