{"version":3,"file":"notifier-container.component.d.ts","sources":["notifier-container.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ChangeDetectorRef, OnDestroy } from '@angular/core';\r\nimport { NotifierNotification } from '../models/notifier-notification.model';\r\nimport { NotifierService } from '../services/notifier.service';\r\nimport { NotifierQueueService } from '../services/notifier-queue.service';\r\nimport { NotifierNotificationComponent } from './notifier-notification.component';\r\n/**\r\n * Notifier container component\r\n * ----------------------------\r\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\r\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\r\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\r\n * by subscribing to its action stream.\r\n *\r\n * Technical sidenote:\r\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\r\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\r\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\r\n */\r\nexport declare class NotifierContainerComponent implements OnDestroy {\r\n    /**\r\n     * List of currently somewhat active notifications\r\n     */\r\n    notifications: Array<NotifierNotification>;\r\n    /**\r\n     * Change detector\r\n     */\r\n    private readonly changeDetector;\r\n    /**\r\n     * Notifier queue service\r\n     */\r\n    private readonly queueService;\r\n    /**\r\n     * Notifier configuration\r\n     */\r\n    private readonly config;\r\n    /**\r\n     * Queue service observable subscription (saved for cleanup)\r\n     */\r\n    private queueServiceSubscription;\r\n    /**\r\n     * Promise resolve function reference, temporarily used while the notification child component gets created\r\n     */\r\n    private tempPromiseResolver;\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param changeDetector       Change detector, used for manually triggering change detection runs\r\n     * @param notifierQueueService Notifier queue service\r\n     * @param notifierService      Notifier service\r\n     */\r\n    constructor(changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService);\r\n    /**\r\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Notification identifier, used as the ngFor trackby function\r\n     *\r\n     * @param   index        Index\r\n     * @param   notification Notifier notification\r\n     * @returns Notification ID as the unique identnfier\r\n     */\r\n    identifyNotification(index: number, notification: NotifierNotification): string;\r\n    /**\r\n     * Event handler, handles clicks on notification dismiss buttons\r\n     *\r\n     * @param notificationId ID of the notification to dismiss\r\n     */\r\n    onNotificationDismiss(notificationId: string): void;\r\n    /**\r\n     * Event handler, handles notification ready events\r\n     *\r\n     * @param notificationComponent Notification component reference\r\n     */\r\n    onNotificationReady(notificationComponent: NotifierNotificationComponent): void;\r\n    /**\r\n     * Handle incoming actions by mapping action types to methods, and then running them\r\n     *\r\n     * @param   action Action object\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleAction;\r\n    /**\r\n     * Show a new notification\r\n     *\r\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\r\n     *\r\n     * @param   action Action object\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleShowAction;\r\n    /**\r\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\r\n     *\r\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\r\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\r\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\r\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\r\n     *\r\n     * @param notification New notification to show\r\n     */\r\n    private continueHandleShowAction;\r\n    /**\r\n     * Hide an existing notification\r\n     *\r\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\r\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\r\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\r\n     *\r\n     * @param   action Action object, payload contains the notification ID\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleHideAction;\r\n    /**\r\n     * Hide the oldest notification (bridge to handleHideAction)\r\n     *\r\n     * @param   action Action object\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleHideOldestAction;\r\n    /**\r\n     * Hide the newest notification (bridge to handleHideAction)\r\n     *\r\n     * @param   action Action object\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleHideNewestAction;\r\n    /**\r\n     * Hide all notifications at once\r\n     *\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private handleHideAllAction;\r\n    /**\r\n     * Shift multiple notifications at once\r\n     *\r\n     * @param   notifications List containing the notifications to be shifted\r\n     * @param   distance      Distance to shift (in px)\r\n     * @param   toMakePlace   Flag, defining in which direciton to shift\r\n     * @returns Promise, resolved when done\r\n     */\r\n    private shiftNotifications;\r\n    /**\r\n     * Add a new notification to the list of notifications (triggers change detection)\r\n     *\r\n     * @param notification Notification to add to the list of notifications\r\n     */\r\n    private addNotificationToList;\r\n    /**\r\n     * Remove an existing notification from the list of notifications (triggers change detection)\r\n     *\r\n     * @param notification Notification to be removed from the list of notifications\r\n     */\r\n    private removeNotificationFromList;\r\n    /**\r\n     * Remove all notifications from the list (triggers change detection)\r\n     */\r\n    private removeAllNotificationsFromList;\r\n    /**\r\n     * Helper: Find a notification in the notification list by a given notification ID\r\n     *\r\n     * @param   notificationId Notification ID, used for finding notification\r\n     * @returns Notification, undefined if not found\r\n     */\r\n    private findNotificationById;\r\n    /**\r\n     * Helper: Find a notification's index by a given notification ID\r\n     *\r\n     * @param   notificationId Notification ID, used for finding a notification's index\r\n     * @returns Notification index, undefined if not found\r\n     */\r\n    private findNotificationIndexById;\r\n}\r\n"]}